■■■퀵 정렬(Quick Sort)■■■

선택정렬, 버블정렬, 삽입정렬 알고리즘은 시간 복잡도가 O(N²)를 가지는 알고리즘
-> 이러한 알고리즘은 데이터 개수가 10만개 이상이 되는 경우 사용하기가 매우 어려운 알고리즘
더욱 빠른 알고리즘 구현 필요 => 퀵 정렬 알고리즘
퀵 정렬 알고리즘은 대표적인 분할 정복 알고리즘으로
분할 정복 알고리즘이란 특정한 배열이 있을 때 그 배열을 반복적으로 분할.
배열의 원소들을 나누어서 계산한다는 점에서 빠른 정렬 알고리즘이라고 할 수 있다.
또한 퀵 정렬 알고리즘은 시간 복잡도가 O(N*logN)이다. (※참고로 logN은 작은 수...)

『특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누기.』

퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬한다.
특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다.

일반적으로 퀵 정렬에는 기준 값(피벗, Pivot)이 존재한다. 
퀵 정렬은 특정한 피벗 값을 기준으로 왼쪽과 오른쪽을 나누는 알고리즘. => 분할 알고리즘

3 7 8 1 5 9 6 10 2 4 
퀵 정렬에서는 피벗 값을 설정할 때 앞에 있는 숫자를 피벗 값으로 많이들 설정한다.

3 7 8 1 5 9 6 10 2 4 
-
→ 피벗 값 3을 기준으로 왼쪽에서 오른쪽으로 검사하고 오른쪽에서 왼쪽으로 검사할 것임.
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 3보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 3보다 작은 값을 선택한다. --ⓑ
즉 ⓐ의 경우는 7, ⓑ의 경우는 2가 된다.
이때 큰 값과 작은 값의 자리를 바꾸어 준다.

3 2 8 1 5 9 6 10 7 4
-
→ 자리를 바꾼 후에도 피벗 값은 여전히 3임.
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 3보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 3보다 작은 값을 선택한다. --ⓑ
즉 ⓐ의 경우는 8, ⓑ의 경우는 1가 된다.
이때 큰 값과 작은 값의 자리를 바꾸어 준다.
 
3 2 1 8 5 9 6 10 7 4
-
→ 자리를 바꾼 후에도 피벗 값은 여전히 3임.
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 3보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 3보다 작은 값을 선택한다. --ⓑ
즉 ⓐ의 경우는 8, ⓑ의 경우는 1이 된다.
※ 이때 8과 1은 서로 엇갈리게 된 상황이다.
즉 작은 값의 인덱스가 큰 값의 인덱스보다 더 작은 상황.
→ 이게 몬소리냐.... 하면
왼쪽에서 오른쪽으로 검사할 때, 즉 정렬 인덱스 수가 커지는 쪽으로 검사할 때는 큰 값
오른쪽에서 왼쪽으로 검사할 때, 즉 정렬 인덱스 수가 작아지는 쪽으로 검사할 때는 작은 값
이게 맞는 건데
1은 [2]에 있고 8은 [3]에 있음. 서로 반대의 상황이어야 수를 바꿀 수 가 있음.
엇갈린 상황일 때에는 왼쪽에 있는 값, 더 작은 값과 피벗 값을 서로 바꿔준다.

1 2 /3/ 8 5 9 6 10 7 4
→ 3은 정렬이 이루어지게 된다.
3을 기준으로 했을 때 3의 왼쪽에 있는 것들은 모두 3보다 작다.
3을 기준으로 했을 때 3의 오른쪽에 있는 것들은 모두 3보다 크다는 특징을 가진다.
분할이 되었다.

왼쪽 집합과 오른쪽 집합을 기준으로 또 각자 반복적으로 수행한다.
1 2 /3/ 8 5 9 6 10 7 4
-         -
→ 왼쪽의 피벗 값은 1 / 오른쪽의 피벗 값은 8이 된다.
1의 피벗 값의 경우
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 1보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 1보다 작은 값을 선택한다. --ⓑ
ⓐ의 경우 2, ⓑ의 경우 없기 때문에 자기 자신의 숫자 1을 고른다.
1과 2는 엇갈린 상황이기 때문에, 작은 숫자 1은 자기 자신을 바꾸게 된다.

/1/ 2 /3/ 8 5 9 6 10 7 4
     -      -
→ 1보다 큰 값은 오른쪽에 있고 1보다 작은 값은 없지만 왼쪽에 있다.
이제는 2가 피벗 값이 된다. 2는 데이터가 한 개기 때문에 그대로 내버려 둔다.
/1/ /2/ /3/ 8 5 9 6 10 7 4
               -
8의 비펏 값의 경우
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 8보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 8보다 작은 값을 선택한다. --ⓑ
ⓐ의 경우는 9, ⓑ의 경우는 4가 된다.
이때 큰 값과 작은 값의 자리를 바꾸어 준다.

/1/ /2/ /3/ 8 5 4 6 10 7 9
               -
→ 자리를 바꾼 후에도 피벗 값은 여전히 8임.
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 8보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 8보다 작은 값을 선택한다. --ⓑ
즉 ⓐ의 경우는 10, ⓑ의 경우는 7이 된다.
엇갈리지 않았으므로 이때 큰 값과 작은 값의 자리를 바꾸어 준다.

/1/ /2/ /3/ 8 5 4 6 7 10 9
              -
→ 자리를 바꾼 후에도 피벗 값은 여전히 8임.
왼쪽에서 오른쪽으로 검사를 할 때에는 피벗 값 8보다 큰 값을 선택한다. --ⓐ
오른쪽에서 왼쪽으로 검사를 할 때에는 피벗 값 8보다 작은 값을 선택한다. --ⓑ
즉 ⓐ의 경우는 10, ⓑ의 경우는 7이 된다.
이때 10과 7은 서로 엇갈렸기 때문에 왼쪽에 있는 값, 더 작은 값과 피벗 값을 서로 바꿔준다.

→ 8은 정렬이 이루어지게 된다.
8을 기준으로 했을 때 8의 왼쪽에 있는 것들은 모두 8보다 작다.
8을 기준으로 했을 때 8의 오른쪽에 있는 것들은 모두 8보다 크다는 특징을 가진다.
분할이 되었다.

왼쪽 집합과 오른쪽 집합을 기준으로 또 각자 반복적으로 수행한다.
/1/ /2/ /3/ 7 5 4 6 /8/ 10 9
              -               --
→ 왼쪽의 피벗 값은 7 / 오른쪽의 피벗 값은 10이 된다.
7의 피벗 값의 경우
자기보다 큰 값을 찾아야 하는데 찾지 못했기 때문에 배열 분할 배열 끝까지 가게 된다.
작은 값은 6이 된다.
또 엇갈린 상황이므로 자기 자신과 바꿔준다.

/1/ /2/ /3/ 6 5 4 /7/ /8/ 10 9
               -                --

                      :

/1/ /2/ /3/ /4/ /5/ /6/ /7/ /8/ /9/ /10/

퀵 정렬은 한 번 정렬을 수행 했을 때 
그 값을 기준으로 왼쪽과 오른쪽으로 나뉘는 특징을 확인할 수 있다.
바로 이것 때문에 퀵 정렬이 빠른 것이다.

직관적인 예시)
1 2 3 4 5 6 7 8 9 10
N² = 10 * 10 = 100

1 2 3 4 5 => 5 * 5 =25
6 7 8 9 10 => 5 * 5 = 25
25 + 25 = 50
잘게 쪼갠 다음 그들을 각자 정렬하고 나중에 합치게 되면 결과적으로 적은 숫자만큼 연산.

