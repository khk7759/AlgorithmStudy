■■■삽입정렬(Insertion Sort)■■■
각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결
선택 정렬, 버블 정렬과 마찬가지로 O(N²)을 가진다는 점에서 비효율적인 알고리즘에 속함.
그러나 선택 정렬, 버블 정렬은 무조건 위치를 바꾸는 방식이었지만 
삽입 정렬은 '필요할 때만' 위치를 바꿈. 
-> 그래서 O(N²)의 시간 복잡도를 가지는 알고리즘 중에서 가장 빠르고 강력한 알고리즘
                 -------------

『각 숫자를 적절한 위치에 삽입』
->이미 정렬이 되어있다고 가정(가정이라는 특성이 조금 더 효율적인 알고리즘이 되게 함.)
 
1 10 5 8 7 6 4 3 2 9 -- ①

_ 1 _ 10 5 8 7 6 4 3 2 9
1 10 5 8 7 6 4 3 2 9 -- ②

_ 1 _ 10 _ 5 8 7 6 4 3 2 9
1 5 10 8 7 6 4 3 2 9 -- ③

_ 1 _ 5 _ 10 _ 8 7 6 4 3 2 9
1 5 8 10 7 6 4 3 2 9 -- ④

_ 1 _ 5 _ 8 _ 10 _ 7 6 4 3 2 9
1 5 7 8 10 6 4 3 2 9 -- ⑤

_ 1 _ 5 _ 7 _ 8 _ 10 _ 6 4 3 2 
-- 6을 기준으로 보았을 때 6의 앞에 있는 숫자들은 이미 정렬이 된 상태
-- 이미 정렬이 되어있기 때문에 추가적으로 앞에서는 더이상 정렬할 필요는 없고
-- 6을 위치를 하나씩 비교해보면서 6보다 큰 값이 왼쪽에 있다면 위치만 바꿔주면 된다.
-- 6의 경우는 앞으로 세 번만 가게 되면 정렬이 완성되므로 
-- 뒤에 수들 뿐만 아니라 앞에 정렬 수들마저 전체 다 살펴볼 필요도 없게 된다.
1 5 6 7 8 10 4 3 2 9 -- ⑥

:

1 2 3 4 5 6 7 8 9 10 -- ⑩

-- 항상 왼쪽 부분은 정렬이 되어있다고 가정하기 때문에
-- 당장 본인이 왼쪽에 있는 수보다 크다면 바로 뒤에서 멈춘다.
-- 즉, 멈출 포인트를 알고 있기 때문에 삽입정렬은 비교적 효율적이다.

10 + 9 + 8 + 7 + ... + 1

=> 등차수열
=> N*(N + 1) / 2
=> 빅-O 표기법을 통해 O(N*N)
=> O(N²)

-------------------------------------------------------------------------------------------------
ex1) 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요

2 3 4 5 6 7 8 9 10 1

만약 데이터가 위와 같이 거의 정렬된 상태라면 삽입정렬이 가장 효율적이다.
삽입정렬은 필요할 때에 한해서만 삽입을 진행하기 때문이다.

풀이)
2 3 4 5 6 7 8 9 10 1 -- 2는 가정이 되어있기 때문에 냅둔다.

2 3 4 5 6 7 8 9 10 1 -- 3은 2보다 크기 때문에 그대로 냅둔다.

2 3 4 5 6 7 8 9 10 1 -- 4는 3보다 크기 때문에 그대로 냅둔다.

            :

2 3 4 5 6 7 8 9 10 1 -- 10은 9보다 크기 때문에 그대로 냅둔다.

-- 여기까지는 한 번씩만 연산을 하고 끝나게 된다. 굉장히 빠르게 연산 처리

_ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ 10 _ 1 -- 오직 1만 한번씩 거쳐가다가

1 2 3 4 5 6 7 8 9 10 -- 본인 자리를 찾고 연산 종료.
-- 1을 만났을 때만 적절한 위치까지 이동을 하게 되는 것이지
-- 1 이전까지는 별다른 연산없이 정렬이 이루어진다.
